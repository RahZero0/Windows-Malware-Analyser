import fs from 'fs/promises';
import { join } from 'node:path'

import { app } from 'electron';

const VOL_MODULES = {
  pslist: extractPslistFeatures,
  dlllist: extractDlllistFeatures,
  handles: extractHandlesFeatures, // only for mac
  ldrmodules: extractLdrModulesFeaturesFromText,
  malfind: extractMalfindFeatures,
  modules: extractModulesFeatures,
  svcscan: extractSvcscanFeatures, // only for mac
  callbacks: extractCallbacksFeatures
}

function extractLdrModulesFeaturesFromText(inputText) {
  try {
    const lines = inputText.split('\n')
    const headers = lines[0].split('\t')

    const ldrmodulesData = lines.slice(1).map((line) => {
      const values = line.split('\t')
      const rowData = {}

      headers.forEach((header, index) => {
        // Convert 'True'/'False' strings to actual boolean values
        rowData[header] = values[index].toLowerCase() === 'true'
      })

      return rowData
    })

    const totalModules = ldrmodulesData.length

    return {
      'ldrmodules.not_in_load': ldrmodulesData.filter((m) => !m.InLoad).length,
      'ldrmodules.not_in_init': ldrmodulesData.filter((m) => !m.InInit).length,
      'ldrmodules.not_in_mem': ldrmodulesData.filter((m) => !m.InMem).length,
      'ldrmodules.not_in_load_avg':
        totalModules > 0 ? ldrmodulesData.filter((m) => !m.InLoad).length / totalModules : 1,
      'ldrmodules.not_in_init_avg':
        totalModules > 0 ? ldrmodulesData.filter((m) => !m.InInit).length / totalModules : 1,
      'ldrmodules.not_in_mem_avg':
        totalModules > 0 ? ldrmodulesData.filter((m) => !m.InMem).length / totalModules : 1
    }
  } catch (error) {
    console.error('Error reading the file:', error)
    return null
  }
}

function extractPslistFeatures(procs) {
  // Extract unique parent process IDs (PPID)
  let ppids = new Set(procs.map((p) => p.PPID))

  // Calculate the average thread count and average handler count
  let avgThreads = procs.reduce((sum, p) => sum + p.Threads, 0) / procs.length
  let avgHandlers = procs.reduce((sum, p) => sum + p.Handles, 0) / procs.length

  return {
    // Number of processes
    'pslist.nproc': procs.length,
    // Number of parent processes
    'pslist.nppid': ppids.size,
    // Average thread count
    'pslist.avg_threads': avgThreads,
    // Average handler count
    'pslist.avg_handlers': avgHandlers
  }
}

function extractDlllistFeatures(dlllist) {
  // Count the number of unique PIDs in the report
  const procs = new Set(dlllist.map((l) => l.PID)).size

  return {
    // Total number of loaded libraries of all processes
    'dlllist.ndlls': dlllist.length,
    // Average loaded libraries per process
    'dlllist.avg_dlls_per_proc': dlllist.length / procs
  }
}

function extractHandlesFeatures(handles) {
  const uniquePIDs = new Set(handles.map((h) => h.PID))

  return {
    // Total number of opened handles
    'handles.nhandles': handles.length,
    // Average handle count per process
    'handles.avg_handles_per_proc': handles.length / uniquePIDs.size
  }
}

function extractModulesFeatures(modules) {
  return {
    'modules.nmodules': modules.length
  }
}

// extract_svcscan_features
function extractSvcscanFeatures(svcscan) {
  return {
    'svcscan.nservices': svcscan.length,
    'svcscan.kernel_drivers': svcscan.filter((s) => s.Type === 'SERVICE_KERNEL_DRIVER').length,
    'svcscan.fs_drivers': svcscan.filter((s) => s.Type === 'SERVICE_FILE_SYSTEM_DRIVER').length,
    'svcscan.process_services': svcscan.filter((s) => s.Type === 'SERVICE_WIN32_OWN_PROCESS').length,
    'svcscan.shared_process_services': svcscan.filter(
      (s) => s.Type === 'SERVICE_WIN32_SHARE_PROCESS'
    ).length,
    'svcscan.nactive': svcscan.filter((s) => s.State === 'SERVICE_RUNNING').length
  }
}

// extract_callbacks_features
function extractCallbacksFeatures(callbacks) {
  return {
    'callbacks.ncallbacks': callbacks.length,
    'callbacks.ngeneric': callbacks.filter((c) => c.Type === 'GenericKernelCallback').length
  }
}

// extract_malfind_features
function extractMalfindFeatures(malfind) {
  const uniquePIDs = new Set(malfind.map((h) => h.PID))

  return {
    'malfind.ninjections': malfind.length,
    'malfind.commitCharge': malfind.filter((h) => h.Protection).length,
    'malfind.protection': malfind.filter((h) => h.CommitCharge).length,
    'malfind.uniqueInjections': malfind.length / uniquePIDs.size
  }
}

// function processAndWriteToCSV() {
//   // Object to store all features
//   let allFeatures = {}
//   const appPath = app.getAppPath('userData')
//   // Iterate over each key in VOL_MODULES
//   for (const [key, extractFunction] of Object.entries(VOL_MODULES)) {
//     const outputFilePath = join(
//       appPath,
//       'extraResources',
//       'v3',
//       'output',
//       key + (key === 'ldrmodules' ? '.txt' : '.json')
//     ).replace(/\\app\.asar\\/g, '\\')
//     try {
//       // Read the file asynchronously
//       const data = readFileSync(outputFilePath, 'utf8')
//       if (key !== 'ldrmodules') {
//         const jsonData = JSON.parse(data)
//         const features = extractFunction(jsonData)
//         allFeatures = { ...allFeatures, ...features }
//       } else {
//         // Call the extract function and accumulate features
//         const features = extractFunction(data)
//         allFeatures = { ...allFeatures, ...features }
//       }
//     } catch (error) {
//       console.error(`Error processing ${key}:`, error)
//     }
//   }
//   return allFeatures
// }

async function processAndWriteToCSV() {
  // Object to store all features
  let allFeatures = {};
  const appPath = app.getAppPath('userData');
  // Iterate over each key in VOL_MODULES
  for (const [key, extractFunction] of Object.entries(VOL_MODULES)) {
    const outputFilePath = join(
      appPath,
      'extraResources',
      'v3',
      'output',
      key + (key === 'ldrmodules' ? '.txt' : '.json')
    ).replace(/\\app\.asar\\/g, '\\');
    try {
      // Read the file asynchronously
      const data = await fs.readFile(outputFilePath, 'utf8');
      if (key !== 'ldrmodules') {
        const jsonData = JSON.parse(data);
        const features = extractFunction(jsonData);
        allFeatures = { ...allFeatures, ...features };
      } else {
        // Call the extract function and accumulate features
        const features = extractFunction(data);
        allFeatures = { ...allFeatures, ...features };
      }
    } catch (error) {
      console.error(`Error processing ${key}:`, error);
    }
  }
  return allFeatures;
}

export default processAndWriteToCSV
